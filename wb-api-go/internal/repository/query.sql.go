// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package repository

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createAttributeDefinition = `-- name: CreateAttributeDefinition :one
insert into world.attribute_definitions
(wbatn, attribute_name, label, data_type)
values
($1, $2, $3, $4)
returning id, wbatn, attribute_name, label, data_type, created_at, updated_at
`

type CreateAttributeDefinitionParams struct {
	Wbatn         string `json:"wbatn"`
	AttributeName string `json:"attribute_name"`
	Label         string `json:"label"`
	DataType      string `json:"data_type"`
}

func (q *Queries) CreateAttributeDefinition(ctx context.Context, db DBTX, arg *CreateAttributeDefinitionParams) (*WorldAttributeDefinition, error) {
	row := db.QueryRowContext(ctx, createAttributeDefinition,
		arg.Wbatn,
		arg.AttributeName,
		arg.Label,
		arg.DataType,
	)
	var i WorldAttributeDefinition
	err := row.Scan(
		&i.ID,
		&i.Wbatn,
		&i.AttributeName,
		&i.Label,
		&i.DataType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createEntity = `-- name: CreateEntity :one
insert into world.entities
(id, type_id, parent_id, wbrn, entity_name, entity_description, notes)
values 
($1, $2, $3, $4, $5, $6, $7)
returning id, type_id, parent_id, wbrn, entity_name, entity_description, notes, created_at, updated_at
`

type CreateEntityParams struct {
	ID                uuid.UUID      `json:"id"`
	TypeID            uuid.UUID      `json:"type_id"`
	ParentID          uuid.UUID      `json:"parent_id"`
	Wbrn              string         `json:"wbrn"`
	EntityName        string         `json:"entity_name"`
	EntityDescription string         `json:"entity_description"`
	Notes             sql.NullString `json:"notes"`
}

func (q *Queries) CreateEntity(ctx context.Context, db DBTX, arg *CreateEntityParams) (*WorldEntity, error) {
	row := db.QueryRowContext(ctx, createEntity,
		arg.ID,
		arg.TypeID,
		arg.ParentID,
		arg.Wbrn,
		arg.EntityName,
		arg.EntityDescription,
		arg.Notes,
	)
	var i WorldEntity
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.ParentID,
		&i.Wbrn,
		&i.EntityName,
		&i.EntityDescription,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createEntityAssociation = `-- name: CreateEntityAssociation :one
insert into world.entity_associations
(entity_one, entity_two, type_id, effective_start_date, effective_end_date)
values 
($1, $2, $3, $4, $5) 
returning id, entity_one, entity_two, type_id, effective_start_date, effective_end_date
`

type CreateEntityAssociationParams struct {
	EntityOne          uuid.UUID    `json:"entity_one"`
	EntityTwo          uuid.UUID    `json:"entity_two"`
	TypeID             uuid.UUID    `json:"type_id"`
	EffectiveStartDate sql.NullTime `json:"effective_start_date"`
	EffectiveEndDate   sql.NullTime `json:"effective_end_date"`
}

func (q *Queries) CreateEntityAssociation(ctx context.Context, db DBTX, arg *CreateEntityAssociationParams) (*WorldEntityAssociation, error) {
	row := db.QueryRowContext(ctx, createEntityAssociation,
		arg.EntityOne,
		arg.EntityTwo,
		arg.TypeID,
		arg.EffectiveStartDate,
		arg.EffectiveEndDate,
	)
	var i WorldEntityAssociation
	err := row.Scan(
		&i.ID,
		&i.EntityOne,
		&i.EntityTwo,
		&i.TypeID,
		&i.EffectiveStartDate,
		&i.EffectiveEndDate,
	)
	return &i, err
}

const createEntityHistory = `-- name: CreateEntityHistory :one
insert into world.entity_history
(entity_id, historic_value)
values 
($1, $2)
returning id, entity_id, historic_value, created_at
`

type CreateEntityHistoryParams struct {
	EntityID      uuid.UUID       `json:"entity_id"`
	HistoricValue json.RawMessage `json:"historic_value"`
}

func (q *Queries) CreateEntityHistory(ctx context.Context, db DBTX, arg *CreateEntityHistoryParams) (*WorldEntityHistory, error) {
	row := db.QueryRowContext(ctx, createEntityHistory, arg.EntityID, arg.HistoricValue)
	var i WorldEntityHistory
	err := row.Scan(
		&i.ID,
		&i.EntityID,
		&i.HistoricValue,
		&i.CreatedAt,
	)
	return &i, err
}

const createType = `-- name: CreateType :one
insert into world.types
(parent_id, wbtn, type_name, type_description)
values 
($1, $2, $3, $4)
returning id, parent_id, wbtn, type_name, type_description, created_at, updated_at
`

type CreateTypeParams struct {
	ParentID        uuid.UUID `json:"parent_id"`
	Wbtn            string    `json:"wbtn"`
	TypeName        string    `json:"type_name"`
	TypeDescription string    `json:"type_description"`
}

func (q *Queries) CreateType(ctx context.Context, db DBTX, arg *CreateTypeParams) (*WorldType, error) {
	row := db.QueryRowContext(ctx, createType,
		arg.ParentID,
		arg.Wbtn,
		arg.TypeName,
		arg.TypeDescription,
	)
	var i WorldType
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Wbtn,
		&i.TypeName,
		&i.TypeDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAttributesForType = `-- name: GetAttributesForType :many
select ad.id, ad.wbatn, ad.attribute_name, ad.label, ad.data_type, ad.created_at, ad.updated_at from
world.attribute_definitions ad inner join world.type_attributes ta
on ad.id = ta.attribute_id 
inner join world.types t on t.id = ta.type_id
where ta.type_id = $1
`

func (q *Queries) GetAttributesForType(ctx context.Context, db DBTX, typeID uuid.UUID) ([]*WorldAttributeDefinition, error) {
	rows, err := db.QueryContext(ctx, getAttributesForType, typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldAttributeDefinition
	for rows.Next() {
		var i WorldAttributeDefinition
		if err := rows.Scan(
			&i.ID,
			&i.Wbatn,
			&i.AttributeName,
			&i.Label,
			&i.DataType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesByCriteria = `-- name: GetEntitiesByCriteria :many
select e.id, e.type_id, e.parent_id, e.wbrn, e.entity_name, e.entity_description, e.notes, e.created_at, e.updated_at
from world.entities e
	inner join world.types w on e.type_id = w.id
	inner join world.entities p on e.parent_id = p.id
where (w.wbtn = $1 or $1 = '')
and (p.wbrn = $2 or $2 = '')
`

type GetEntitiesByCriteriaParams struct {
	Wbtn string `json:"wbtn"`
	Wbrn string `json:"wbrn"`
}

func (q *Queries) GetEntitiesByCriteria(ctx context.Context, db DBTX, arg *GetEntitiesByCriteriaParams) ([]*WorldEntity, error) {
	rows, err := db.QueryContext(ctx, getEntitiesByCriteria, arg.Wbtn, arg.Wbrn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldEntity
	for rows.Next() {
		var i WorldEntity
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.ParentID,
			&i.Wbrn,
			&i.EntityName,
			&i.EntityDescription,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesByParent = `-- name: GetEntitiesByParent :many
select e.id, e.type_id, e.parent_id, e.wbrn, e.entity_name, e.entity_description, e.notes, e.created_at, e.updated_at from world.entities e
where e.parent_id = $1
`

func (q *Queries) GetEntitiesByParent(ctx context.Context, db DBTX, parentID uuid.UUID) ([]*WorldEntity, error) {
	rows, err := db.QueryContext(ctx, getEntitiesByParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldEntity
	for rows.Next() {
		var i WorldEntity
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.ParentID,
			&i.Wbrn,
			&i.EntityName,
			&i.EntityDescription,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesByWBRN = `-- name: GetEntitiesByWBRN :many
select e.id, e.type_id, e.parent_id, e.wbrn, e.entity_name, e.entity_description, e.notes, e.created_at, e.updated_at from world.entities e
where e.wbrn like $1
`

func (q *Queries) GetEntitiesByWBRN(ctx context.Context, db DBTX, wbrn string) ([]*WorldEntity, error) {
	rows, err := db.QueryContext(ctx, getEntitiesByWBRN, wbrn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldEntity
	for rows.Next() {
		var i WorldEntity
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.ParentID,
			&i.Wbrn,
			&i.EntityName,
			&i.EntityDescription,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntity = `-- name: GetEntity :one
select e.id, e.type_id, e.parent_id, e.wbrn, e.entity_name, e.entity_description, e.notes, e.created_at, e.updated_at from world.entities e where id = $1
`

func (q *Queries) GetEntity(ctx context.Context, db DBTX, id uuid.UUID) (*WorldEntity, error) {
	row := db.QueryRowContext(ctx, getEntity, id)
	var i WorldEntity
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.ParentID,
		&i.Wbrn,
		&i.EntityName,
		&i.EntityDescription,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getEntityAssociationsForEntity = `-- name: GetEntityAssociationsForEntity :many
select id, entity_one, entity_two, type_id, effective_start_date, effective_end_date
from world.entity_associations
where (entity_one = $1 or entity_two = $1)
`

func (q *Queries) GetEntityAssociationsForEntity(ctx context.Context, db DBTX, entityOne uuid.UUID) ([]*WorldEntityAssociation, error) {
	rows, err := db.QueryContext(ctx, getEntityAssociationsForEntity, entityOne)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldEntityAssociation
	for rows.Next() {
		var i WorldEntityAssociation
		if err := rows.Scan(
			&i.ID,
			&i.EntityOne,
			&i.EntityTwo,
			&i.TypeID,
			&i.EffectiveStartDate,
			&i.EffectiveEndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityAttributes = `-- name: GetEntityAttributes :many
select id, entity_id, attribute_id, attribute_value, created_at, updated_at from 
world.entity_attributes 
where entity_id = $1
`

func (q *Queries) GetEntityAttributes(ctx context.Context, db DBTX, entityID uuid.UUID) ([]*WorldEntityAttribute, error) {
	rows, err := db.QueryContext(ctx, getEntityAttributes, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldEntityAttribute
	for rows.Next() {
		var i WorldEntityAttribute
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.AttributeID,
			&i.AttributeValue,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityByWBRN = `-- name: GetEntityByWBRN :one
select e.id, e.type_id, e.parent_id, e.wbrn, e.entity_name, e.entity_description, e.notes, e.created_at, e.updated_at from world.entities e
where e.wbrn = $1
`

func (q *Queries) GetEntityByWBRN(ctx context.Context, db DBTX, wbrn string) (*WorldEntity, error) {
	row := db.QueryRowContext(ctx, getEntityByWBRN, wbrn)
	var i WorldEntity
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.ParentID,
		&i.Wbrn,
		&i.EntityName,
		&i.EntityDescription,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getEntityChildReferences = `-- name: GetEntityChildReferences :many
select e.id as entity_id, e.entity_name as entity_name, e.wbrn as resource_name, t.wbtn as type_name
from world.entities e inner join world.types t on e.type_id = t.id 
where e.parent_id = $1
`

type GetEntityChildReferencesRow struct {
	EntityID     uuid.UUID `json:"entity_id"`
	EntityName   string    `json:"entity_name"`
	ResourceName string    `json:"resource_name"`
	TypeName     string    `json:"type_name"`
}

func (q *Queries) GetEntityChildReferences(ctx context.Context, db DBTX, parentID uuid.UUID) ([]*GetEntityChildReferencesRow, error) {
	rows, err := db.QueryContext(ctx, getEntityChildReferences, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetEntityChildReferencesRow
	for rows.Next() {
		var i GetEntityChildReferencesRow
		if err := rows.Scan(
			&i.EntityID,
			&i.EntityName,
			&i.ResourceName,
			&i.TypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityHistory = `-- name: GetEntityHistory :many
select id, entity_id, historic_value, created_at
from world.entity_history 
where entity_id = $1
order by created_at
`

func (q *Queries) GetEntityHistory(ctx context.Context, db DBTX, entityID uuid.UUID) ([]*WorldEntityHistory, error) {
	rows, err := db.QueryContext(ctx, getEntityHistory, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldEntityHistory
	for rows.Next() {
		var i WorldEntityHistory
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.HistoricValue,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityReference = `-- name: GetEntityReference :one
select e.ID as entity_id, e.entity_name as entity_name, e.wbrn as resource_name, t.wbtn as type_name
from world.entities e inner join world.types t on e.type_id = t.id 
where e.id = $1
`

type GetEntityReferenceRow struct {
	EntityID     uuid.UUID `json:"entity_id"`
	EntityName   string    `json:"entity_name"`
	ResourceName string    `json:"resource_name"`
	TypeName     string    `json:"type_name"`
}

func (q *Queries) GetEntityReference(ctx context.Context, db DBTX, id uuid.UUID) (*GetEntityReferenceRow, error) {
	row := db.QueryRowContext(ctx, getEntityReference, id)
	var i GetEntityReferenceRow
	err := row.Scan(
		&i.EntityID,
		&i.EntityName,
		&i.ResourceName,
		&i.TypeName,
	)
	return &i, err
}

const getEntityReferenceByWBRN = `-- name: GetEntityReferenceByWBRN :one
select e.ID as entity_id, e.entity_name as entity_name, e.wbrn as resource_name, t.wbtn as type_name
from world.entities e inner join world.types t on e.type_id = t.id 
where e.wbrn = $1
`

type GetEntityReferenceByWBRNRow struct {
	EntityID     uuid.UUID `json:"entity_id"`
	EntityName   string    `json:"entity_name"`
	ResourceName string    `json:"resource_name"`
	TypeName     string    `json:"type_name"`
}

func (q *Queries) GetEntityReferenceByWBRN(ctx context.Context, db DBTX, wbrn string) (*GetEntityReferenceByWBRNRow, error) {
	row := db.QueryRowContext(ctx, getEntityReferenceByWBRN, wbrn)
	var i GetEntityReferenceByWBRNRow
	err := row.Scan(
		&i.EntityID,
		&i.EntityName,
		&i.ResourceName,
		&i.TypeName,
	)
	return &i, err
}

const getTypeByID = `-- name: GetTypeByID :one
select id, parent_id, wbtn, type_name, type_description, created_at, updated_at from world.types
where id = $1
`

func (q *Queries) GetTypeByID(ctx context.Context, db DBTX, id uuid.UUID) (*WorldType, error) {
	row := db.QueryRowContext(ctx, getTypeByID, id)
	var i WorldType
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Wbtn,
		&i.TypeName,
		&i.TypeDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getTypeByWBTN = `-- name: GetTypeByWBTN :one
select id, parent_id, wbtn, type_name, type_description, created_at, updated_at from world.types
where wbtn = $1
`

func (q *Queries) GetTypeByWBTN(ctx context.Context, db DBTX, wbtn string) (*WorldType, error) {
	row := db.QueryRowContext(ctx, getTypeByWBTN, wbtn)
	var i WorldType
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Wbtn,
		&i.TypeName,
		&i.TypeDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
