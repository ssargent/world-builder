// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package worldbuilder

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAttributeDefinition = `-- name: CreateAttributeDefinition :one
insert into world.attribute_definitions
(wbatn, attribute_name, label, data_type)
values
($1, $2, $3, $4)
returning id, wbatn, attribute_name, label, data_type, created_at, updated_at
`

type CreateAttributeDefinitionParams struct {
	Wbatn         string `json:"wbatn"`
	AttributeName string `json:"attribute_name"`
	Label         string `json:"label"`
	DataType      string `json:"data_type"`
}

func (q *Queries) CreateAttributeDefinition(ctx context.Context, db DBTX, arg *CreateAttributeDefinitionParams) (*WorldAttributeDefinition, error) {
	row := db.QueryRow(ctx, createAttributeDefinition,
		arg.Wbatn,
		arg.AttributeName,
		arg.Label,
		arg.DataType,
	)
	var i WorldAttributeDefinition
	err := row.Scan(
		&i.ID,
		&i.Wbatn,
		&i.AttributeName,
		&i.Label,
		&i.DataType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createEntity = `-- name: CreateEntity :one
insert into world.entities
(id, type_id, parent_id, wbrn, entity_name, entity_description, notes)
values 
($1, $2, $3, $4, $5, $6, $7)
returning id, type_id, parent_id, wbrn, entity_name, entity_description, notes, created_at, updated_at
`

type CreateEntityParams struct {
	ID                pgtype.UUID `json:"id"`
	TypeID            pgtype.UUID `json:"type_id"`
	ParentID          pgtype.UUID `json:"parent_id"`
	Wbrn              string      `json:"wbrn"`
	EntityName        string      `json:"entity_name"`
	EntityDescription string      `json:"entity_description"`
	Notes             pgtype.Text `json:"notes"`
}

func (q *Queries) CreateEntity(ctx context.Context, db DBTX, arg *CreateEntityParams) (*WorldEntity, error) {
	row := db.QueryRow(ctx, createEntity,
		arg.ID,
		arg.TypeID,
		arg.ParentID,
		arg.Wbrn,
		arg.EntityName,
		arg.EntityDescription,
		arg.Notes,
	)
	var i WorldEntity
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.ParentID,
		&i.Wbrn,
		&i.EntityName,
		&i.EntityDescription,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createType = `-- name: CreateType :one
insert into world.types
(parent_id, wbtn, type_name, type_description)
values 
($1, $2, $3, $4)
returning id, parent_id, wbtn, type_name, type_description, created_at, updated_at
`

type CreateTypeParams struct {
	ParentID        pgtype.UUID `json:"parent_id"`
	Wbtn            string      `json:"wbtn"`
	TypeName        string      `json:"type_name"`
	TypeDescription string      `json:"type_description"`
}

func (q *Queries) CreateType(ctx context.Context, db DBTX, arg *CreateTypeParams) (*WorldType, error) {
	row := db.QueryRow(ctx, createType,
		arg.ParentID,
		arg.Wbtn,
		arg.TypeName,
		arg.TypeDescription,
	)
	var i WorldType
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Wbtn,
		&i.TypeName,
		&i.TypeDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAttributesForType = `-- name: GetAttributesForType :many
select ad.id, ad.wbatn, ad.attribute_name, ad.label, ad.data_type, ad.created_at, ad.updated_at from
world.attribute_definitions ad inner join world.type_attributes ta
on ad.id = ta.attribute_id 
inner join world.types t on t.id = ta.type_id
where ta.type_id = $1
`

func (q *Queries) GetAttributesForType(ctx context.Context, db DBTX, typeID pgtype.UUID) ([]*WorldAttributeDefinition, error) {
	rows, err := db.Query(ctx, getAttributesForType, typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldAttributeDefinition
	for rows.Next() {
		var i WorldAttributeDefinition
		if err := rows.Scan(
			&i.ID,
			&i.Wbatn,
			&i.AttributeName,
			&i.Label,
			&i.DataType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesByWBRN = `-- name: GetEntitiesByWBRN :many
select e.id, e.type_id, e.parent_id, e.wbrn, e.entity_name, e.entity_description, e.notes, e.created_at, e.updated_at from world.entities e
where e.wbrn like $1
`

func (q *Queries) GetEntitiesByWBRN(ctx context.Context, db DBTX, wbrn string) ([]*WorldEntity, error) {
	rows, err := db.Query(ctx, getEntitiesByWBRN, wbrn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldEntity
	for rows.Next() {
		var i WorldEntity
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.ParentID,
			&i.Wbrn,
			&i.EntityName,
			&i.EntityDescription,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityAttributes = `-- name: GetEntityAttributes :many
select id, entity_id, attribute_id, attribute_value, created_at, updated_at from 
world.entity_attributes 
where entity_id = $1
`

func (q *Queries) GetEntityAttributes(ctx context.Context, db DBTX, entityID pgtype.UUID) ([]*WorldEntityAttribute, error) {
	rows, err := db.Query(ctx, getEntityAttributes, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorldEntityAttribute
	for rows.Next() {
		var i WorldEntityAttribute
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.AttributeID,
			&i.AttributeValue,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityByWBRN = `-- name: GetEntityByWBRN :one
select e.id, e.type_id, e.parent_id, e.wbrn, e.entity_name, e.entity_description, e.notes, e.created_at, e.updated_at from world.entities e
where e.wbrn = $1
`

func (q *Queries) GetEntityByWBRN(ctx context.Context, db DBTX, wbrn string) (*WorldEntity, error) {
	row := db.QueryRow(ctx, getEntityByWBRN, wbrn)
	var i WorldEntity
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.ParentID,
		&i.Wbrn,
		&i.EntityName,
		&i.EntityDescription,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getTypeByID = `-- name: GetTypeByID :one
select id, parent_id, wbtn, type_name, type_description, created_at, updated_at from world.types
where id = $1
`

func (q *Queries) GetTypeByID(ctx context.Context, db DBTX, id pgtype.UUID) (*WorldType, error) {
	row := db.QueryRow(ctx, getTypeByID, id)
	var i WorldType
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Wbtn,
		&i.TypeName,
		&i.TypeDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getTypeByWBTN = `-- name: GetTypeByWBTN :one
select id, parent_id, wbtn, type_name, type_description, created_at, updated_at from world.types
where wbtn = $1
`

func (q *Queries) GetTypeByWBTN(ctx context.Context, db DBTX, wbtn string) (*WorldType, error) {
	row := db.QueryRow(ctx, getTypeByWBTN, wbtn)
	var i WorldType
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Wbtn,
		&i.TypeName,
		&i.TypeDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
